# Week 8 - Cubical Agda Exercises

## Standard disclaimer:

**The exercises are designed to increase in difficulty so that we can cater to
our large and diverse audience. This also means that it is *perfectly fine* if
you don't manage to do all exercises: some of them are definitely a bit hard for
beginners and there are likely too many exercises! You *may* wish to come back
to them later when you have learned more.**

Having said that, here we go!

In case you haven't done the other Agda exercises:
This is a markdown file with Agda code, which means that it displays nicely on
GitHub, but at the same time you can load this file in Agda and fill the holes
to solve exercises.

**When solving the problems,
please make a copy of this file to work in, so that it doesn't get overwritten
(in case we update the exercises through `git`)!**


```agda
{-# OPTIONS --cubical --allow-unsolved-metas #-}

module Exercises9 where

open import cubical-prelude
open import Lecture7-notes
open import Lecture8-notes
open import Lecture9-notes
open import Solutions7
open import Solutions8
open import Lecture9-live hiding (_∙_ ; ua)
```

### Exercise 1 (2x):
Show the left cancellation law for path composition
Hint: one hcomp should suffice. Use comp-filler and connections

```agda

lUnit : {A : Type ℓ} {x y : A} (p : x ≡ y) → refl ∙ p ≡ p
lUnit {x = x} {y = y} p i j =
  hcomp (λ k → λ {(i = i0) → comp-filler refl p k j
                 ; (i = i1) → p (j ∧ k)
                 ; (j = i0) → x
                 ; (j = i1) → p k})
        x


```

### Exercise 2
Here is another HIT describing binary numbers. The idea is that a binary number is a list of booleans, modulo trailing zeros.

For instance, true ∷ false ∷ true ∷ [] is the binary number 101...
... and so is true ∷ false ∷ true ∷ false ∷ false ∷ []
```agda
0B = false
1B = true

data ListBin : Type where
  []    : ListBin
  _∷_   : (x : Bool) (xs : ListBin) → ListBin
  drop0 : 0B ∷ [] ≡ []
```
(a) Define the successor function on ListBin
```agda

postulate
  isSetℕ : isSet ℕ

1LB : ListBin
1LB = 1B ∷ []

sucListBin : ListBin → ListBin
sucListBin [] = 1LB
sucListBin (true ∷ xs) = false ∷ sucListBin xs
sucListBin (false ∷ xs) = 1B ∷ xs
sucListBin (drop0 i) = 1LB

```
(b) Define addition (_+LB_) on ListBin and prove that x +LB [] ≡ x
Do this by mutual induction! Make sure the three cases for the right unit law hold by refl.
```agda

_+LB_ : ListBin → ListBin → ListBin
rUnit+LB : (x : ListBin) → x +LB [] ≡ x
[] +LB y = y
(x ∷ xs) +LB [] = x ∷ xs
(true ∷ xs) +LB (true ∷ ys) = false ∷ sucListBin (xs +LB ys)
(true ∷ xs) +LB (false ∷ ys) = true ∷ (xs +LB ys)
(false ∷ xs) +LB (true ∷ ys) = true ∷ (xs +LB ys)
(false ∷ xs) +LB (false ∷ ys) = false ∷ (xs +LB ys)
(true ∷ xs) +LB drop0 i = true ∷ (rUnit+LB xs i)
(false ∷ xs) +LB drop0 i = false ∷ (rUnit+LB xs i)
drop0 i +LB [] = drop0 i
drop0 i +LB (true ∷ y) = true ∷ y
drop0 i +LB (false ∷ y) = false ∷ y
drop0 i +LB drop0 j = drop0 (j ∧ i)
rUnit+LB [] = refl
rUnit+LB (x ∷ x₁) = refl
rUnit+LB (drop0 i) = refl

```
(c) Prove that sucListBin is left distributive over +LB
Hint: If you pattern match deep enough, there will be a lot of refls...
```agda

sucListBinDistrL : (x y : ListBin) → sucListBin (x +LB y) ≡ (sucListBin x +LB y)
sucListBinDistrL [] [] = refl
sucListBinDistrL [] (true ∷ y) = refl
sucListBinDistrL [] (false ∷ y) = refl
sucListBinDistrL [] (drop0 i) = refl
sucListBinDistrL (true ∷ xs) [] = refl
sucListBinDistrL (false ∷ xs) [] = refl
sucListBinDistrL (true ∷ xs) (true ∷ y) = ap (1B ∷_) (sucListBinDistrL xs y)
sucListBinDistrL (true ∷ xs) (false ∷ y) = ap (0B ∷_) (sucListBinDistrL xs y)
sucListBinDistrL (false ∷ xs) (true ∷ y) = refl
sucListBinDistrL (false ∷ xs) (false ∷ y) = refl
sucListBinDistrL (true ∷ []) (drop0 i)  = refl
sucListBinDistrL (true ∷ (true ∷ xs)) (drop0 i) = refl
sucListBinDistrL (true ∷ (false ∷ xs)) (drop0 i) = refl
sucListBinDistrL (true ∷ drop0 i) (drop0 j) = refl
sucListBinDistrL (false ∷ xs) (drop0 i) = refl
sucListBinDistrL (drop0 i) [] = refl
sucListBinDistrL (drop0 i) (true ∷ y) = refl
sucListBinDistrL (drop0 i) (false ∷ y) = refl
sucListBinDistrL (drop0 i) (drop0 j) = refl
```

(d) Define maps back and forth from ListBin and ℕ

```agda

LB→ℕ : ListBin → ℕ
LB→ℕ [] = 0
LB→ℕ (true ∷ xs) = suc (2 · LB→ℕ xs)
LB→ℕ (false ∷ xs) = 2 · LB→ℕ xs
LB→ℕ (drop0 i) = 0

ℕ→LB : ℕ → ListBin
ℕ→LB zero = []
ℕ→LB (suc x) = sucListBin (ℕ→LB x)

7LB : ListBin
7LB = 1B ∷ 1B ∷ 1B ∷ []

4LB : ListBin
4LB = 0B ∷ 0B ∷ 1B ∷ 0B ∷ []

test : (LB→ℕ 7LB ≡ 7) × (LB→ℕ 4LB ≡ 4)
     × (LB→ℕ (7LB +LB 4LB) ≡ 11)
     × (LB→ℕ (4LB +LB 7LB) ≡ 11)
test = refl , refl , refl , refl




ℕ→LB-pres+ : (x y : ℕ) → ℕ→LB (x + y) ≡ (ℕ→LB x +LB ℕ→LB y)
ℕ→LB-pres+ zero y = refl
ℕ→LB-pres+ (suc x) zero =
  ap sucListBin (ap ℕ→LB (+-comm x zero)) ∙ sym (rUnit+LB (sucListBin (ℕ→LB x)))
ℕ→LB-pres+ (suc x) (suc y) =
  ap sucListBin (ℕ→LB-pres+ x (suc y))
   ∙ sucListBinDistrL (ℕ→LB x) (sucListBin (ℕ→LB y))

LB→ℕ-suc : (x : ListBin) → LB→ℕ (sucListBin x) ≡ suc (LB→ℕ x)
LB→ℕ-suc [] = refl
LB→ℕ-suc (true ∷ xs) = ap (λ x → x + x) (LB→ℕ-suc xs) ∙ ap suc (sym (+-suc (LB→ℕ xs) (LB→ℕ xs)))
LB→ℕ-suc (false ∷ xs) = refl
LB→ℕ-suc (drop0 i) = refl


+assoc : (x y z : ℕ) → (x + y) + z ≡ x + (y + z)
+assoc zero y z = refl
+assoc (suc x) y z = ap suc (+assoc x y z)

move4 : (x y z w : ℕ) → (x + y) + (z + w) ≡ (x + z) + (y + w)
move4 x y z w =
  (x + y) + (z + w) ≡⟨ sym (+assoc (x + y) z w) ⟩
  ((x + y) + z) + w ≡⟨ ap (_+ w) (+assoc x y z
                    ∙ ap (x +_) (+-comm y z)
                    ∙ sym (+assoc x z y)) ⟩
  ((x + z) + y) + w ≡⟨ +assoc (x + z) y w ⟩
  ((x + z) + (y + w)) ∎

reflℕ : (x : ℕ) (p : x ≡ x) → p ≡ refl
reflℕ x p  = isSetℕ _ _ _ _

LB→ℕ-pres+ : (x y : ListBin) → LB→ℕ (x +LB y) ≡ (LB→ℕ x + LB→ℕ y)
LB→ℕ-pres+ [] y = refl
LB→ℕ-pres+ (true ∷ xs) [] = ap suc (+-comm 0 (LB→ℕ xs + LB→ℕ xs))
LB→ℕ-pres+ (true ∷ xs) (true ∷ y) = ap (λ x → x + x) (LB→ℕ-suc (xs +LB y))
                                    ∙ ap suc (sym (+-suc _ _))
                                    ∙ ap (2 +_) (ap (λ x → x + x) (LB→ℕ-pres+ xs y)
                                              ∙ move4 (LB→ℕ xs) (LB→ℕ y) (LB→ℕ xs) (LB→ℕ y))
                                    ∙ ap suc (+-suc _ _)
LB→ℕ-pres+ (true ∷ xs) (false ∷ y) = ap suc (ap (λ x → x + x) (LB→ℕ-pres+ xs y)
                                            ∙ move4 (LB→ℕ xs) (LB→ℕ y) (LB→ℕ xs) (LB→ℕ y))
LB→ℕ-pres+ (true ∷ xs) (drop0 i) =
  isProp→PathP {A = λ i → suc (LB→ℕ (rUnit+LB xs i) + LB→ℕ (rUnit+LB xs i))
                          ≡ suc ((LB→ℕ xs + LB→ℕ xs) + 0)}
    (λ _ → isSetℕ _ _)
    (ap suc
         (ap (λ x → x + x) (LB→ℕ-pres+ xs []) ∙
          move4 (LB→ℕ xs) 0 (LB→ℕ xs) 0))
    (ap suc (+-comm 0 (LB→ℕ xs + LB→ℕ xs))) i
LB→ℕ-pres+ (false ∷ xs) [] = +-comm zero _
LB→ℕ-pres+ (false ∷ xs) (true ∷ y) = ap suc (ap (λ x → x + x) (LB→ℕ-pres+ xs y) ∙
          move4 (LB→ℕ xs) (LB→ℕ y) (LB→ℕ xs) (LB→ℕ y))
          ∙ +-suc (LB→ℕ xs + LB→ℕ xs)  (LB→ℕ y + LB→ℕ y)
LB→ℕ-pres+ (false ∷ xs) (false ∷ y) =
    ap (λ x → x + x) (LB→ℕ-pres+ xs y)
  ∙ move4 (LB→ℕ xs) (LB→ℕ y) (LB→ℕ xs) (LB→ℕ y)
LB→ℕ-pres+ (false ∷ xs) (drop0 i) =
  isProp→PathP {A = λ i → LB→ℕ (rUnit+LB xs i) + LB→ℕ (rUnit+LB xs i) ≡
      (LB→ℕ xs + LB→ℕ xs) + 0}
      (λ _ → isSetℕ _ _)
      (ap (λ x → x + x) (LB→ℕ-pres+ xs []) ∙
         move4 (LB→ℕ xs) 0 (LB→ℕ xs) 0)
      (+-comm zero (LB→ℕ xs + LB→ℕ xs)) i
LB→ℕ-pres+ (drop0 i) [] = refl
LB→ℕ-pres+ (drop0 i) (true ∷ xs) =
  reflℕ (suc (LB→ℕ xs + LB→ℕ xs))
         (ap suc
          (refl ∙ move4 0 (LB→ℕ xs) 0 (LB→ℕ xs))
          ∙ refl) i
LB→ℕ-pres+ (drop0 i) (false ∷ ys) =
  reflℕ (LB→ℕ ys + LB→ℕ ys) (refl ∙ move4 0 (LB→ℕ ys) 0 (LB→ℕ ys)) i
LB→ℕ-pres+ (drop0 i) (drop0 j) = help j i
  where
  help :  PathP (λ j → isProp→PathP (λ _ → isSetℕ 0 0)
           (refl ∙ move4 0 0 0 0) refl j ≡ refl)
           (reflℕ 0 (refl ∙ move4 0 0 0 0)) refl
  help = toPathP (isProp→isSet (isSetℕ 0 0) _ _ _ _)

lem2 : (xs : ListBin) → (xs +LB xs) ≡ (false ∷ xs)
lem2 [] = sym drop0
lem2 (true ∷ xs) = ap (false ∷_) (ap sucListBin (lem2 xs))
lem2 (false ∷ xs) = ap (false ∷_) (lem2 xs)
lem2 (drop0 i) j =
  hcomp (λ k → λ {(i = i0) → false ∷ drop0 (~ j ∨ ~ k)
                 ; (i = i1) → drop0 (~ j)
                 ; (j = i0) → drop0 i
                 ; (j = i1) → false ∷ drop0 (i ∨ ~ k)})
        (drop0 (~ j ∧ i))

lem1 : (xs : ListBin) → sucListBin (xs +LB xs) ≡ (true ∷ xs)
lem1 [] = refl
lem1 (true ∷ xs) = ap (true ∷_) (lem1 xs)
lem1 (false ∷ xs) = ap (true ∷_) (lem2 xs) 
lem1 (drop0 i) j = true ∷ drop0 (i ∨ ~ j)

retr : (x : ListBin) → ℕ→LB (LB→ℕ x) ≡ x
retr [] = refl
retr (true ∷ xs) =
    ap sucListBin (ℕ→LB-pres+ (LB→ℕ xs) (LB→ℕ xs) ∙ ap (λ x → x +LB x) (retr xs))
  ∙ lem1 xs
retr (false ∷ xs) =
    (ℕ→LB-pres+ (LB→ℕ xs) (LB→ℕ xs) ∙ (ap (λ x → x +LB x) (retr xs))) -- ap ℕ→LB {!!}
  ∙ lem2 xs
retr (drop0 i) = help i
  where
  lem : (refl ∙ refl) ∙ sym drop0 ≡ sym drop0
  lem = ap (_∙ sym drop0) (rUnit refl) ∙  lUnit (sym drop0)

  help : PathP (λ i → [] ≡ drop0 i) ((refl ∙ refl) ∙ sym drop0) refl
  help i j = hcomp (λ k → λ {(i = i0) → lem (~ k) j
                            ; (i = i1) → []
                            ; (j = i0) → []
                            ; (j = i1) → drop0 i})
                   (drop0 (i ∨ ~ j))


sect : (x : ℕ) → LB→ℕ (ℕ→LB x) ≡ x
sect zero = refl
sect (suc x) = LB→ℕ-suc (ℕ→LB x) ∙ ap suc (sect x)

is : Iso ListBin ℕ
Iso.fun is = LB→ℕ
Iso.inv is = ℕ→LB
Iso.rightInv is = sect
Iso.leftInv is = retr

ListBin≡ℕ : ListBin ≡ ℕ
ListBin≡ℕ = isoToPath is

```

```agda

uncurry : {A : Type ℓ} {B : A → Type ℓ'} {C : (a : A) → B a → Type ℓ''}
  → ((a : A) → (p : B a) → C a p)
  → (x : Σ A B) → C (pr₁ x) (pr₂ x)
uncurry f (x , y) = f x y

isCheapMagma : Type ℓ → Type ℓ
isCheapMagma A = {!!}

CheapMagma : (ℓ : Level) → Type (lsuc ℓ)
CheapMagma ℓ = Σ A ꞉ Type ℓ , (A → A → A)

SIP : ∀ {ℓ ℓ'} {A B : Type ℓ} {S : Type ℓ → Type ℓ'}
    → (e : A ≃ B)
    → (AS : S A) (BS : S B)
    → subst S (ua e) AS ≡ BS
    → Path (Σ (Type ℓ) S) (A , AS) (B , BS)
pr₁ (SIP e AS BS r i) = ua e i
pr₂ (SIP {S = S} e AS BS r i) = toPathP {A = λ i → S (ua e i)} r i

CheapMagma≡ : {M N : CheapMagma ℓ}
            → (f : pr₁ M ≃ pr₁ N)
            → ((x y : pr₁ M) → pr₁ f (pr₂ M x y) ≡ pr₂ N (pr₁ f x) (pr₁ f y))
            → M ≡ N
CheapMagma≡ {M = M} eq id  = SIP eq _ _ (funExt λ x → funExt λ y → {!!})

gra : (x y : ℕ) → ℕ
gra x y = LB→ℕ ((ℕ→LB x) +LB (ℕ→LB y))


{- 
data ListBin-raw : Type where
  []    : ListBin-raw
  _∷_   : Bool → ListBin-raw → ListBin-raw
-}

```

-- ## (a) When does a function from ListBin-raw induce a function from ListBin?

-- ```agda


-- ```


-- ## (a) Define the group structure on Bool (inversion is just the identity). That is define/provve the following

-- ```agda

-- not : Bool → Bool
-- not true = false
-- not false = true

-- notnot : (x : Bool) → not (not x) ≡ x
-- notnot true = refl
-- notnot false = refl

-- _+B_ : Bool → Bool → Bool
-- true +B y = not y
-- false +B y = y

-- rUnit+B : (x : Bool) → x +B 0B ≡ x
-- rUnit+B true = refl
-- rUnit+B false = refl

-- lUnit+B : (x : Bool) → 0B +B x ≡ x
-- lUnit+B x = refl

-- cancel+B : (x : Bool) → x +B x ≡ 0B
-- cancel+B true = refl
-- cancel+B false = refl

-- assoc+B : (x y z : Bool) → (x +B (y +B z)) ≡ ((x +B y) +B z)
-- assoc+B true true z = notnot z
-- assoc+B true false z = refl
-- assoc+B false y z = refl

-- ListBin→ : {!!}
-- ListBin→ = {!!}


-- cancel0 : {!(x : ListBin) → ?!}
-- cancel0 = {!!}

-- concListBin : ListBin → ListBin → ListBin
-- concListBin [] y = y
-- concListBin (x ∷ xs) y = x ∷ concListBin xs y
-- concListBin (drop0 xs i) y = drop0 (concListBin xs y) i

-- lenListBin : ListBin → ℕ
-- lenListBin [] = 0
-- lenListBin (true ∷ xs) = suc (lenListBin xs)
-- lenListBin (false ∷ xs) = lenListBin xs
-- lenListBin (drop0 x i) = lenListBin x

-- zeroList : (n : ℕ) → ListBin
-- zeroList zero = []
-- zeroList (suc n) = {!!}

-- add-1 : (n : ℕ) → ListBin
-- add-1 zero = true ∷ []
-- add-1 (suc n) = {!true !}

-- _+LB_ : ListBin → ListBin → ListBin
-- [] +LB y = y
-- (true ∷ xs) +LB y = {!!}
-- (false ∷ xs) +LB y = xs +LB y
-- drop0 x i +LB y = x +LB y

-- ```







-- -- ```agda
-- -- isPropPathP : {A : I → Type ℓ} {x : A i0} {y : A i1}
-- --             → isSet (A i0) → isProp (PathP A x y)
-- -- isPropPathP {A = A} {x = x} {y = y} is-set =
-- --   transport (λ j → isProp
-- --                (PathP (λ i → A (i ∧ j))
-- --                       x
-- --                       (transp (λ i → A (j ∨ ~ i)) j y)))
-- --              (is-set x (transport (λ i → A (~ i)) y))

-- -- module _ {A : Type ℓ} {B : LFSet A → Type ℓ'}
-- --   ([]* : B [])
-- --   (_∷*_ : (x : A) {xs : LFSet A} → B xs → B (x ∷ xs))
-- --   (comm* : (x y : A) {xs : LFSet A} (b : B xs)
-- --     → PathP (λ i → B (comm x y xs i)) (x ∷* (y ∷* b)) (y ∷* (x ∷* b)))
-- --   (dup* : (x : A) {xs : LFSet A} (b : B xs)
-- --     → PathP (λ i → B (dup x xs i)) (x ∷* (x ∷* b)) (x ∷* b))
-- --   (trunc* : (xs : LFSet A) → isSet (B xs))
-- --   where
-- --   elimFS : (x : LFSet A) → B x
-- --   elimFS [] = []*
-- --   elimFS (x ∷ xs) = x ∷* elimFS xs
-- --   elimFS (dup x xs i) = dup* x (elimFS xs) i
-- --   elimFS (comm x y xs i) = comm* x y (elimFS xs) i
-- --   elimFS (trunc x y p q i j) = lem i j
-- --     where
-- --     lem : PathP (λ i → PathP (λ j → B (trunc x y p q i j))
-- --                 (elimFS x) (elimFS y))
-- --                 (λ j → elimFS (p j))
-- --                 λ j → elimFS (q j)
-- --     lem = toPathP (isProp→PathP (λ i → isPropPathP (trunc* x)) _ _)
-- -- ```

-- -- ## (b)
-- -- When eliminating into a proposition, things get easier: we only need
-- -- to define the map for [] and _∷_. Prove this.

-- -- ```agda
-- -- PropElimLFS : {A : Type ℓ}
-- --   {B : LFSet A → Type ℓ'}
-- --   → B []
-- --   → ((x : A) {xs : LFSet A} → B xs → B (x ∷ xs))
-- --   → ((xs : LFSet A) → isProp (B xs))
-- --   → (x : LFSet A) → B x
-- -- PropElimLFS {B = B} []* _∷*_ is-prop =
-- --   elimFS []* _∷*_
-- --     (λ x y b → isProp→PathP (λ i → is-prop (comm x y _ i)) _ _)
-- --     (λ x b → isProp→PathP (λ i → is-prop (dup x _ i)) _ _)
-- --     (λ x → isProp→isSet (is-prop x))
-- -- ```

-- -- ### Exercise 2 (★★)
-- -- ## An alternative implemenation of Fin n {0,...,n-1} is as follows

-- -- ```agda
-- -- data Fin : ℕ → Type₀ where
-- --   zero : {n : ℕ} → Fin (suc n)
-- --   suc  : {n : ℕ} (i : Fin n) → Fin (suc n)

-- -- data ∥_∥ (A : Type ℓ) : Type ℓ where
-- --   ∣_∣ : A → ∥ A ∥
-- --   squash : (x y : ∥ A ∥) → x ≡ y

-- -- truncElim : {A : Type ℓ} {B : ∥ A ∥ → Type ℓ'}
-- --          → ((x : A) → B ∣ x ∣)
-- --          → ((x : ∥ A ∥) → isProp (B x))
-- --          → (x : ∥ A ∥) → B x
-- -- truncElim ∣_∣* propB ∣ x ∣ = ∣ x ∣*
-- -- truncElim {B = B} ∣_∣* propB (squash x y i) =
-- --   isProp→PathP {A = λ i → B (squash x y i)}
-- --     (λ _ → propB _)
-- --     (truncElim ∣_∣* propB x) (truncElim ∣_∣* propB y) i

-- -- ```
-- -- here's another implemenation of finite sets:
-- -- ```agda


-- -- isInjective :  {A : Type ℓ} {B : Type ℓ'} (f : A → B)
-- --   → Type (ℓ ⊔ ℓ')
-- -- isInjective {A = A} f = (x y : A) → f x ≡ f y → ∥ x ≡ y ∥

-- -- data FinSet2 (A : Type ℓ) : Type ℓ where
-- --   inc : (n : ℕ) (f : Fin n → A) (inj-f : isInjective f) → FinSet2 A
-- --   is-set : isSet (FinSet2 A)
-- -- ```

-- -- ## (a) define the eliminator, recursor, and elimProp for FinSet2
-- -- ```agda
-- -- module _ {A : Type ℓ} {B : FinSet2 A → Type ℓ'}
-- --   (inc* : (n : ℕ) (f : Fin n → A) (inj-f : isInjective f) → B (inc n f inj-f))
-- --   (is-set* : ((x : FinSet2 A) → isSet (B x)))
-- --   where
-- --   elimFS2 : (x : FinSet2 A) → B x
-- --   elimFS2 (inc n f inj-f) = inc* n f inj-f
-- --   elimFS2 (is-set x y p q i j) = lem i j
-- --     where
-- --     lem : PathP (λ i → PathP (λ j → B (is-set x y p q i j))
-- --                   (elimFS2 x) (elimFS2 y))
-- --                   (λ j → elimFS2 (p j))
-- --                   λ j → elimFS2 (q j)
-- --     lem = toPathP (isProp→PathP (λ i → isPropPathP (is-set* x)) _ _)


-- -- elimPropFS2 : {A : Type ℓ}
-- --      {B : FinSet2 A → Type ℓ'}
-- --   → ((n : ℕ) (f : Fin n → A) (inj-f : isInjective f) → B (inc n f inj-f))
-- --   → ((xs : FinSet2 A) → isProp (B xs))
-- --   → (x : FinSet2 A) → B x
-- -- elimPropFS2 inc* is-prop =
-- --   elimFS2
-- --     inc*
-- --     λ x → isProp→isSet (is-prop x)


-- -- restrict : {B : Type ℓ} {n : ℕ} (f : Fin (suc n) → B) → Fin n → B
-- -- restrict f x = f (suc x)

-- -- predFin : {n : ℕ} → (x₀ : Fin n) → Fin (suc n) → Fin n
-- -- predFin {n = suc n} x₀ zero = zero
-- -- predFin {n = suc n} x₀ (suc x) = x

-- -- restrict-inj : {B : Type ℓ} (n : ℕ) (f : Fin (suc n) → B)
-- --              → isInjective f → isInjective (restrict f)
-- -- restrict-inj (suc n) f inj x y p = {!!} -- ap (predFin x) (inj (suc x) (suc y) p)

-- -- -- module _ {A : Type ℓ} where
-- -- --   inc→LFSet : (n : ℕ) (f : Fin n → A) (inj-f : isInjective f) → LFSet A
-- -- --   inc→LFSet zero f inj-f = []
-- -- --   inc→LFSet (suc n) f inj-f = f zero ∷ inc→LFSet n (restrict f) (restrict-inj n f inj-f)

-- -- --   inc→LFSet≡ : (n : ℕ) (f : Fin n → A) (inj-f inj-f' : isInjective f) →
-- -- --       inc→LFSet n f inj-f ≡ inc→LFSet n f inj-f'
-- -- --   inc→LFSet≡ zero f inj-f inj-f' = refl
-- -- --   inc→LFSet≡ (suc n) f inj-f inj-f' =
-- -- --     ap (f zero ∷_) (inc→LFSet≡ n (restrict f) (restrict-inj _ f inj-f) (restrict-inj _ f inj-f'))

-- -- --   FS2→LFS : FinSet2 A → LFSet A
-- -- --   FS2→LFS = elimFS2 inc→LFSet inc→LFSet≡ λ _ → trunc

-- -- --   LFS→FS2 : LFSet A → FinSet2 A
-- -- --   LFS→FS2 = elimFS (inc 0 (λ {()}) λ {()})
-- -- --                     (λ x {xs} p → {!!})
-- -- --                     {!!}
-- -- --                     {!!} λ _ → is-set


-- -- -- ```




-- -- -- -- Prove the propositional computation law for `J`:

-- -- -- -- ```agda
-- -- -- -- data LFSet (A : Type ℓ) : Type ℓ where
-- -- -- --   []    : LFSet A
-- -- -- --   _∷_   : (x : A) → (xs : LFSet A) → LFSet A
-- -- -- --   dup   : ∀ x xs   → x ∷ x ∷ xs ≡ x ∷ xs
-- -- -- --   comm  : ∀ x y xs → x ∷ y ∷ xs ≡ y ∷ x ∷ xs
-- -- -- --   trunc : isSet (LFSet A)

-- -- -- -- ```



-- -- -- -- -- ```agda
-- -- -- -- -- JRefl' : {A : Type ℓ} {x : A} (P : (z : A) → x ≡ z → Type ℓ'')
-- -- -- -- --   (d : P x refl) → J P d refl ≡ d
-- -- -- -- -- JRefl' P d = {!!}
-- -- -- -- -- ```

-- -- -- -- -- ### Exercise 2 (★★)

-- -- -- -- -- Using `transp`, construct a method for turning dependent paths into paths.

-- -- -- -- -- **Hint**:
-- -- -- -- -- Transport the point `p i` to the fibre `A i1`, and set `φ = i` such that the
-- -- -- -- -- transport computes away at `i = i1`.
-- -- -- -- -- ```text
-- -- -- -- --    x ----(p i)----> y
-- -- -- -- --   A i0    A i      A i1
-- -- -- -- -- ```

-- -- -- -- -- ```agda
-- -- -- -- -- fromPathP : {A : I → Type ℓ} {x : A i0} {y : A i1} →
-- -- -- -- --   PathP A x y → transport (λ i → A i) x ≡ y
-- -- -- -- -- fromPathP {A = A} p i = {!!}
-- -- -- -- -- ```

-- -- -- -- -- ### Exercise 3 (★★★)

-- -- -- -- -- Using `hcomp`, cunstruct a method for turning paths into dependent paths.

-- -- -- -- -- **Hint**:
-- -- -- -- -- At each point `i`, the verical fibre of the following diagram should lie in
-- -- -- -- -- `A i`. The key is to parametrise the bottom line with a dependent path from `x`
-- -- -- -- -- to `transport A x`. This requires writing a `transp` that computes away at
-- -- -- -- -- `i = i0`.

-- -- -- -- -- ```text
-- -- -- -- --        x  - - - -> y
-- -- -- -- --        ^           ^
-- -- -- -- --        ¦           ¦
-- -- -- -- --   refl ¦           ¦ p i
-- -- -- -- --        ¦           ¦
-- -- -- -- --        ¦           ¦
-- -- -- -- --        x ---> transport A x
-- -- -- -- -- ```


-- -- -- -- -- ```agda
-- -- -- -- -- toPathP : {A : I → Type ℓ} {x : A i0} {y : A i1} →
-- -- -- -- --   transport (λ i → A i) x ≡ y → PathP A x y
-- -- -- -- -- toPathP {A = A} {x = x} p i =
-- -- -- -- --   hcomp
-- -- -- -- --     (λ {j (i = i0) → {!!} ;
-- -- -- -- --         j (i = i1) → {!!} })
-- -- -- -- --    {!!}
-- -- -- -- -- ```

-- -- -- -- -- ### Exercise 4 (★)

-- -- -- -- -- Using `toPathP`, prove the following lemma, which lets you fill in dependent
-- -- -- -- -- lines in hProps, provided their boundary.

-- -- -- -- -- ```agda
-- -- -- -- -- isProp→PathP : {A : I → Type ℓ} (p : (i : I) → isProp (A i))
-- -- -- -- --   (a₀ : A i0) (a₁ : A i1) → PathP A a₀ a₁
-- -- -- -- -- isProp→PathP p a₀ a₁ = {!!}
-- -- -- -- -- ```

-- -- -- -- -- ### Exercise 5 (★★)

-- -- -- -- -- Prove the following lemma charictarising equality in subtypes:

-- -- -- -- -- ```agda
-- -- -- -- -- Σ≡Prop : {A : Type ℓ} {B : A → Type ℓ'} {u v : Σ A B} (h : (x : A) → isProp (B x))
-- -- -- -- --        → (p : pr₁ u ≡ pr₁ v) → u ≡ v
-- -- -- -- -- Σ≡Prop {B = B} {u = u} {v = v} h p = {!!}
-- -- -- -- -- ```

-- -- -- -- -- ### Exercise 6 (★★★)

-- -- -- -- -- Prove that `isContr` is a proposition:

-- -- -- -- -- **Hint**:
-- -- -- -- -- This requires drawing a cube (yes, an actual 3D one)!

-- -- -- -- -- ```agda
-- -- -- -- -- isPropIsContr : {A : Type ℓ} → isProp (isContr A)
-- -- -- -- -- isPropIsContr (c0 , h0) (c1 , h1) j = {!!} 
-- -- -- -- -- ```
